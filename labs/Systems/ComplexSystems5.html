<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Complex Systems Lab · Unit 5 · Criticality & Phase Transitions</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.2/lib/p5.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        body {
            background: #050314;
            color: #f4f4f5;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }

        .top-bar {
            position: sticky;
            top: 0;
            z-index: 20;
            backdrop-filter: blur(10px);
            background: radial-gradient(circle at top left, rgba(248, 250, 252, 0.16), transparent),
                rgba(9, 9, 11, 0.96);
            border-bottom: 1px solid rgba(39, 39, 42, 0.9);
        }

        .sketch-card {
            border-radius: 1.25rem;
            border: 1px solid #27272a;
            background: radial-gradient(circle at top, rgba(248, 250, 252, 0.08), transparent 55%),
                rgba(15, 15, 19, 0.98);
            box-shadow:
                0 18px 45px rgba(0, 0, 0, 0.7),
                0 0 24px rgba(148, 163, 184, 0.16);
        }

        .sketch-holder {
            position: relative;
            width: 100%;
            height: 260px;
            border-radius: 0.9rem;
            overflow: hidden;
            background: radial-gradient(circle at center, #020617, #020617 35%, #020617);
        }

        .pill {
            border-radius: 999px;
            border: 1px solid rgba(161, 161, 170, 0.4);
            padding: 0.15rem 0.6rem;
            font-size: 0.65rem;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            color: #a1a1aa;
        }

        .badge-live {
            border-radius: 999px;
            padding: 0.2rem 0.65rem;
            font-size: 0.7rem;
            background: rgba(248, 250, 252, 0.14);
            color: #e5e7eb;
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
        }

        .badge-live span {
            width: 6px;
            height: 6px;
            border-radius: 999px;
            background: #f97316;
            box-shadow: 0 0 8px rgba(249, 115, 22, 0.9);
        }

        /* Sidebar + toggle */
        .sidebar-toggle {
            position: fixed;
            right: 1.5rem;
            bottom: 1.5rem;
            z-index: 40;
            width: 3rem;
            height: 3rem;
            border-radius: 999px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(248, 250, 252, 0.7);
            background: radial-gradient(circle at 30% 20%, rgba(249, 115, 22, 0.7), transparent),
                rgba(15, 23, 42, 0.96);
            box-shadow:
                0 0 18px rgba(249, 115, 22, 0.7),
                0 0 40px rgba(249, 115, 22, 0.4);
            cursor: pointer;
            transition: transform 0.18s ease, box-shadow 0.18s ease, background 0.18s ease;
        }

        .sidebar-toggle span {
            display: block;
            font-size: 1.35rem;
            line-height: 1;
            color: #fefce8;
        }

        .sidebar-toggle:hover {
            transform: translateY(-1px) scale(1.03);
            box-shadow:
                0 0 22px rgba(249, 115, 22, 0.9),
                0 0 55px rgba(249, 115, 22, 0.45);
        }

        .info-sidebar {
            position: fixed;
            top: 0;
            right: 0;
            height: 100vh;
            width: min(440px, 100%);
            background: radial-gradient(circle at top, rgba(248, 250, 252, 0.12), transparent 55%),
                #020617;
            border-left: 1px solid rgba(248, 250, 252, 0.4);
            box-shadow: -18px 0 40px rgba(0, 0, 0, 0.85);
            z-index: 50;
            transform: translateX(100%);
            transition: transform 0.25s ease-out;
            display: flex;
            flex-direction: column;
        }

        .info-sidebar-header {
            padding: 0.85rem 1.2rem;
            border-bottom: 1px solid rgba(39, 39, 42, 0.9);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem;
            background: rgba(2, 6, 23, 0.96);
        }

        .info-sidebar-body {
            padding: 0.75rem 1.2rem 1.2rem;
            overflow-y: auto;
            font-size: 0.78rem;
        }

        .info-section {
            border-radius: 0.85rem;
            padding: 0.65rem 0.75rem 0.8rem;
            margin-bottom: 0.75rem;
            background: rgba(12, 10, 26, 0.97);
            border: 1px solid rgba(39, 39, 42, 0.9);
        }

        .info-section h3 {
            font-size: 0.8rem;
            font-weight: 600;
            margin: 0 0 0.25rem;
        }

        .info-section p {
            margin: 0.12rem 0;
        }

        .info-section code {
            font-size: 0.7rem;
            padding: 0.12rem 0.25rem;
            border-radius: 0.25rem;
            background: rgba(24, 24, 27, 0.9);
        }

        .info-section ul {
            margin: 0.25rem 0 0.3rem 0.95rem;
            padding: 0;
        }

        .info-section li {
            margin-bottom: 0.15rem;
        }

        .info-chip {
            font-size: 0.65rem;
            border-radius: 999px;
            padding: 0.1rem 0.45rem;
            border: 1px solid rgba(248, 250, 252, 0.7);
            color: #fefce8;
        }

        .info-overlay {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at top, rgba(248, 250, 252, 0.06), transparent 60%),
                rgba(2, 6, 23, 0.88);
            z-index: 45;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease-out;
        }

        body.sidebar-open .info-sidebar {
            transform: translateX(0);
        }

        body.sidebar-open .info-overlay {
            opacity: 1;
            pointer-events: auto;
        }
    </style>
</head>

<body>
    <!-- Top bar -->
    <header class="top-bar">
        <div class="mx-auto max-w-5xl px-4 py-3 flex items-center justify-between gap-3">
            <div class="flex items-center gap-3">
                <a href="ComplexSystemsHub.html"
                    class="inline-flex items-center gap-1 rounded-full border border-zinc-700/80 px-3 py-1 text-xs text-zinc-200 hover:border-emerald-400/80 hover:text-emerald-200 transition">
                    ← Back to Complex Systems Hub
                </a>
                <div class="pill">Complex Systems Lab · Unit 5</div>
            </div>
            <div class="badge-live">
                <span></span>
                criticality · avalanches · phase changes
            </div>
        </div>
    </header>

    <main class="mx-auto max-w-5xl px-4 pt-6 pb-16 space-y-8">
        <!-- Intro -->
        <section class="space-y-2">
            <h1 class="text-xl md:text-2xl font-semibold tracking-tight">
                Criticality & Phase Transitions
            </h1>
            <p class="text-sm text-zinc-400 max-w-2xl">
                Now we look at <span class="text-amber-300">how systems snap between regimes</span>:
                ordered vs disordered, subcritical vs supercritical, no avalanche vs system-spanning events.
                This is where “just a bit more” load, temperature, or probability flips everything.
            </p>
        </section>

        <!-- Grid of topics -->
        <section class="grid gap-6 md:grid-cols-2">
            <!-- Ising model -->
            <article class="sketch-card p-4 flex flex-col gap-3">
                <div class="flex items-center justify-between gap-3">
                    <div>
                        <h2 class="text-sm font-semibold text-sky-200">
                            2D Ising Model (Spins on a Lattice)
                        </h2>
                        <p class="text-xs text-zinc-400">
                            Simple ferromagnet: spins want to align with neighbors. Temperature decides order vs noise.
                        </p>
                    </div>
                    <div class="flex flex-col items-end gap-1">
                        <span class="text-[0.65rem] text-zinc-500 uppercase tracking-wide">Phase model</span>
                        <div class="flex flex-wrap gap-1.5">
                            <span class="pill">Ising</span>
                            <span class="pill">T ≈ 2.2 J</span>
                        </div>
                    </div>
                </div>

                <div id="ising-holder" class="sketch-holder"></div>

                <div class="flex flex-wrap items-center justify-between gap-2 text-[0.7rem] text-zinc-400 mt-1">
                    <span>Blue = spin down, gold = spin up.</span>
                    <span>Domains grow / break near critical T.</span>
                </div>
            </article>

            <!-- Sandpile -->
            <article class="sketch-card p-4 flex flex-col gap-3">
                <div class="flex items-center justify-between gap-3">
                    <div>
                        <h2 class="text-sm font-semibold text-amber-200">
                            Sandpile · Self-Organized Criticality
                        </h2>
                        <p class="text-xs text-zinc-400">
                            Add grains slowly, topple when too steep → avalanches of all sizes.
                        </p>
                    </div>
                    <div class="flex flex-col items-end gap-1">
                        <span class="text-[0.65rem] text-zinc-500 uppercase tracking-wide">Avalanches</span>
                        <div class="flex flex-wrap gap-1.5">
                            <span class="pill">BTW sandpile</span>
                        </div>
                    </div>
                </div>

                <div id="sandpile-holder" class="sketch-holder"></div>

                <div class="flex flex-wrap items-center justify-between gap-2 text-[0.7rem] text-zinc-400 mt-1">
                    <span>Heights 0–3 in different colors.</span>
                    <span>System tunes itself to critical slope.</span>
                </div>
            </article>

            <!-- Percolation -->
            <article class="sketch-card p-4 flex flex-col gap-3">
                <div class="flex items-center justify-between gap-3">
                    <div>
                        <h2 class="text-sm font-semibold text-emerald-200">
                            Percolation on a Grid
                        </h2>
                        <p class="text-xs text-zinc-400">
                            Randomly open cells with probability p. At a threshold, a big cluster spans the system.
                        </p>
                    </div>
                    <div class="flex flex-col items-end gap-1">
                        <span class="text-[0.65rem] text-zinc-500 uppercase tracking-wide">Connectivity</span>
                        <div class="flex flex-wrap gap-1.5">
                            <span class="pill">site percolation</span>
                            <span class="pill">p ≈ 0.59</span>
                        </div>
                    </div>
                </div>

                <div id="percolation-holder" class="sketch-holder"></div>

                <div class="flex flex-wrap items-center justify-between gap-2 text-[0.7rem] text-zinc-400 mt-1">
                    <span>Green = spanning cluster from top.</span>
                    <span>Subcritical vs supercritical connectivity.</span>
                </div>
            </article>

            <!-- Forest fire -->
            <article class="sketch-card p-4 flex flex-col gap-3">
                <div class="flex items-center justify-between gap-3">
                    <div>
                        <h2 class="text-sm font-semibold text-rose-200">
                            Forest-Fire Model
                        </h2>
                        <p class="text-xs text-zinc-400">
                            Trees grow, lightning strikes, fires burn clusters → driven dissipative critical system.
                        </p>
                    </div>
                    <div class="flex flex-col items-end gap-1">
                        <span class="text-[0.65rem] text-zinc-500 uppercase tracking-wide">Dynamical criticality</span>
                        <div class="flex flex-wrap gap-1.5">
                            <span class="pill">trees ⧖ fire</span>
                        </div>
                    </div>
                </div>

                <div id="forest-holder" class="sketch-holder"></div>

                <div class="flex flex-wrap items-center justify-between gap-2 text-[0.7rem] text-zinc-400 mt-1">
                    <span>Green = trees, red = burning, dark = empty.</span>
                    <span>Intermittent bursts of activity.</span>
                </div>
            </article>
        </section>
    </main>

    <!-- Overlay & Sidebar toggle -->
    <div id="info-overlay" class="info-overlay"></div>

    <button id="info-toggle" class="sidebar-toggle" aria-label="Open system explanations">
        <span>+</span>
    </button>

    <!-- Info Sidebar -->
    <aside id="info-sidebar" class="info-sidebar" aria-label="Simulation explanations">
        <div class="info-sidebar-header">
            <div class="flex flex-col">
                <span class="text-xs font-semibold text-amber-300 tracking-wide uppercase">
                    Unit 5 · Criticality & Phase Transitions
                </span>
                <span class="text-[0.72rem] text-zinc-400">
                    From magnets and sand to fires and connectivity: how systems sit right at the edge of a change.
                </span>
            </div>
            <button id="info-close"
                class="inline-flex items-center justify-center rounded-full border border-zinc-700/70 text-xs text-zinc-200 w-7 h-7 hover:border-amber-400/70 hover:text-amber-200 transition"
                aria-label="Close">
                ✕
            </button>
        </div>
        <div class="info-sidebar-body">
            <!-- Ising -->
            <section class="info-section">
                <div class="flex items-center justify-between mb-1">
                    <h3 class="text-sky-300">2D Ising Model</h3>
                    <span class="info-chip">order ↔ disorder</span>
                </div>
                <p><strong>Idea:</strong> Each lattice site has a spin <code>sᵢ = ±1</code>. Neighboring spins prefer
                    to align. Temperature introduces randomness.</p>
                <p class="mt-1 text-zinc-300">Energy (Hamiltonian):</p>
                <p class="text-zinc-200">
                    <code>H = −J Σ⟨i,j⟩ sᵢ sⱼ − h Σᵢ sᵢ</code>
                </p>
                <ul class="text-zinc-300">
                    <li><code>J &gt; 0</code> → alignment is energetically favored.</li>
                    <li><code>h</code> is an external magnetic field (we keep h = 0 in this demo).</li>
                </ul>
                <p class="text-zinc-300">
                    We use the Metropolis rule: flip a spin with probability
                    <code>min(1, exp(−ΔH / (kT)))</code>.
                </p>
                <p class="mt-1 text-zinc-300"><strong>Why it’s cool:</strong></p>
                <ul class="text-zinc-300">
                    <li>Below a critical temperature <code>T_c</code>: large domains, net magnetization ≠ 0.</li>
                    <li>Above <code>T_c</code>: spins mostly random, magnetization ≈ 0.</li>
                    <li>Right near <code>T_c</code> you get long-range correlations and scale-free structures.</li>
                </ul>
                <p class="text-zinc-300">
                    This is the canonical “phase transition” toy model used everywhere from ferromagnets to
                    opinion-dynamics analogies.
                </p>
            </section>

            <!-- Sandpile -->
            <section class="info-section">
                <div class="flex items-center justify-between mb-1">
                    <h3 class="text-amber-300">Sandpile · Self-Organized Criticality (SOC)</h3>
                    <span class="info-chip">avalanches of all sizes</span>
                </div>
                <p><strong>Idea:</strong> You add grains of sand one at a time on a grid. If a site holds 4 or more
                    grains, it topples: it gives 1 grain to each of its four neighbors.</p>
                <p class="mt-1 text-zinc-300">Update rule (Bak–Tang–Wiesenfeld):</p>
                <ul class="text-zinc-300">
                    <li>Choose a site i and do <code>zᵢ ← zᵢ + 1</code>.</li>
                    <li>If any <code>zᵢ ≥ 4</code>, then repeatedly:
                        <ul>
                            <li><code>zᵢ ← zᵢ − 4</code></li>
                            <li>Each neighbor j: <code>zⱼ ← zⱼ + 1</code></li>
                        </ul>
                    </li>
                </ul>
                <p class="text-zinc-300">
                    The system naturally evolves to a critical state where adding a single grain can cause
                    tiny or giant avalanches.
                </p>
                <p class="mt-1 text-zinc-300"><strong>Real-world echoes:</strong></p>
                <ul class="text-zinc-300">
                    <li>Earthquakes (stick-slip on faults).</li>
                    <li>Load shedding in power grids.</li>
                    <li>Alarm storms / log storms in industrial systems.</li>
                </ul>
            </section>

            <!-- Percolation -->
            <section class="info-section">
                <div class="flex items-center justify-between mb-1">
                    <h3 class="text-emerald-300">Percolation</h3>
                    <span class="info-chip">connectivity threshold</span>
                </div>
                <p><strong>Idea:</strong> Each site on a grid is open with probability <code>p</code>. We ask:
                    is there a connected path of open sites from the top to the bottom?</p>
                <ul class="text-zinc-300">
                    <li>For small <code>p</code>: only small isolated clusters.</li>
                    <li>Near a critical <code>p_c</code> (~0.59 for 2D site percolation): a giant component appears.
                    </li>
                    <li>Above <code>p_c</code>: spanning cluster almost surely.</li>
                </ul>
                <p class="text-zinc-300">
                    In the visualization, we recolor the part of the cluster reachable from the top as green.
                </p>
                <p class="mt-1 text-zinc-300"><strong>Real-world links:</strong></p>
                <ul class="text-zinc-300">
                    <li>Will a fire or epidemic cross a region?</li>
                    <li>Connectivity in communication networks or sensor fields.</li>
                    <li>Fluid flow in porous media (oil, water, etc.).</li>
                </ul>
            </section>

            <!-- Forest fire -->
            <section class="info-section">
                <div class="flex items-center justify-between mb-1">
                    <h3 class="text-rose-300">Forest-Fire Model</h3>
                    <span class="info-chip">driven · dissipative</span>
                </div>
                <p><strong>Idea:</strong> A grid of cells that can be empty, tree, or burning. Trees grow slowly,
                    lightning (rarely) ignites them, fires spread quickly, then leave emptiness behind.</p>
                <p class="mt-1 text-zinc-300">
                    Simplified rules:
                </p>
                <ul class="text-zinc-300">
                    <li>Empty → tree with probability <code>p_grow</code>.</li>
                    <li>Tree with burning neighbor → burning.</li>
                    <li>Tree → burning with small probability <code>p_lightning</code>.</li>
                    <li>Burning → empty.</li>
                </ul>
                <p class="text-zinc-300">
                    When <code>p_grow</code> and <code>p_lightning</code> live in the right range, the system shows
                    bursts of fires of many different sizes (another SOC-like behavior).
                </p>
                <p class="mt-1 text-zinc-300"><strong>Real-world echoes:</strong></p>
                <ul class="text-zinc-300">
                    <li>Forest ecology and fire regimes.</li>
                    <li>“Load → failure → reset” cycles in infrastructure.</li>
                    <li>Activity bursts in neural networks or markets.</li>
                </ul>
            </section>

            <!-- Mapping -->
            <section class="info-section">
                <h3 class="text-zinc-200 mb-1">Mapping to my toolbox</h3>
                <p class="text-zinc-300">
                    Unit 5 is a mental model for “edge of failure / edge of order”:
                </p>
                <ul class="text-zinc-300">
                    <li><strong>Ising:</strong> order parameter & critical temperature → think “how aligned is the
                        system?”</li>
                    <li><strong>Sandpile:</strong> slow drive, fast release → think “does my system self-tune to an
                        avalanche regime?”</li>
                    <li><strong>Percolation:</strong> how connected is the topology, and what's the threshold for global
                        spread?</li>
                    <li><strong>Forest-fire:</strong> interplay between build-up and dissipation → bursts instead of
                        steady state.</li>
                </ul>
                <p class="text-zinc-300">
                    For Network monitoring, alerts based on logs, and HMI displays: these are great metaphors for
                    alert storms, failure
                    cascades, and regimes where you want to keep the system <em>near</em> but not <em>past</em> a
                    critical point.
                </p>
            </section>
        </div>
    </aside>

    <!-- Ising p5.js -->
    <script>
        (function () {
            const isingSketch = (p) => {
                let canvas, holder;
                const L = 42;
                let spins = [];
                const J = 1.0;
                const T = 2.2; // near critical in 2D Ising
                const STEPS_PER_FRAME = 300;

                function initLattice() {
                    spins = new Array(L);
                    for (let i = 0; i < L; i++) {
                        spins[i] = new Array(L);
                        for (let j = 0; j < L; j++) {
                            spins[i][j] = Math.random() < 0.5 ? 1 : -1;
                        }
                    }
                }

                function deltaEnergy(i, j) {
                    const s = spins[i][j];
                    const up = spins[(i - 1 + L) % L][j];
                    const down = spins[(i + 1) % L][j];
                    const left = spins[i][(j - 1 + L) % L];
                    const right = spins[i][(j + 1) % L];
                    const sum = up + down + left + right;
                    return 2 * J * s * sum;
                }

                function metropolisStep() {
                    for (let n = 0; n < STEPS_PER_FRAME; n++) {
                        const i = Math.floor(Math.random() * L);
                        const j = Math.floor(Math.random() * L);
                        const dE = deltaEnergy(i, j);
                        if (dE <= 0) {
                            spins[i][j] *= -1;
                        } else {
                            const prob = Math.exp(-dE / T);
                            if (Math.random() < prob) {
                                spins[i][j] *= -1;
                            }
                        }
                    }
                }

                function resizeCanvasToHolder() {
                    if (!holder) return;
                    const rect = holder.getBoundingClientRect();
                    const w = Math.max(260, rect.width);
                    const h = rect.height || 260;
                    p.resizeCanvas(w, h);
                }

                p.setup = () => {
                    holder = document.getElementById("ising-holder");
                    const rect = holder.getBoundingClientRect();
                    const w = Math.max(260, rect.width);
                    const h = rect.height || 260;
                    canvas = p.createCanvas(w, h);
                    canvas.parent(holder);
                    p.frameRate(30);
                    initLattice();
                };

                p.windowResized = () => {
                    resizeCanvasToHolder();
                };

                p.draw = () => {
                    metropolisStep();

                    p.background(4, 6, 18);
                    const cellSize = Math.min(p.width, p.height) * 0.75 / L;
                    const offsetX = (p.width - cellSize * L) / 2;
                    const offsetY = (p.height - cellSize * L) / 2;

                    for (let i = 0; i < L; i++) {
                        for (let j = 0; j < L; j++) {
                            const s = spins[i][j];
                            if (s > 0) {
                                p.fill(252, 211, 77);
                            } else {
                                p.fill(59, 130, 246);
                            }
                            p.noStroke();
                            p.rect(offsetX + j * cellSize, offsetY + i * cellSize, cellSize + 0.5,
                                cellSize + 0.5);
                        }
                    }

                    // HUD
                    p.noStroke();
                    p.fill(15, 23, 42, 220);
                    p.rect(0, 0, 260, 38);
                    p.fill(224, 231, 255);
                    p.textAlign(p.LEFT, p.TOP);
                    p.textSize(10);
                    p.text("2D Ising model (spins)", 8, 6);
                    p.fill(148, 163, 184);
                    p.textSize(9);

                    // simple magnetization estimate
                    let m = 0;
                    for (let i = 0; i < L; i++) {
                        for (let j = 0; j < L; j++) {
                            m += spins[i][j];
                        }
                    }
                    m /= (L * L);
                    p.text(`magnetization ≈ ${m.toFixed(2)}`, 8, 20);
                };
            };

            new p5(isingSketch);
        })();
    </script>

    <!-- Sandpile p5.js -->
    <script>
        (function () {
            const sandSketch = (p) => {
                let canvas, holder;
                const W = 40;
                const H = 30;
                let grid = [];
                const TOPPLE = 4;
                const DROPS_PER_FRAME = 3;

                function initGrid() {
                    grid = new Array(H);
                    for (let y = 0; y < H; y++) {
                        grid[y] = new Array(W);
                        for (let x = 0; x < W; x++) {
                            grid[y][x] = 0;
                        }
                    }
                }

                function dropGrain() {
                    const x = Math.floor(W / 2) + Math.floor((Math.random() - 0.5) * 6);
                    const y = Math.floor(H / 2) + Math.floor((Math.random() - 0.5) * 6);
                    const clampedX = Math.max(0, Math.min(W - 1, x));
                    const clampedY = Math.max(0, Math.min(H - 1, y));
                    grid[clampedY][clampedX] += 1;
                }

                function relax() {
                    let unstable = true;
                    let safety = 0;
                    while (unstable && safety < 5000) {
                        unstable = false;
                        safety++;
                        for (let y = 0; y < H; y++) {
                            for (let x = 0; x < W; x++) {
                                if (grid[y][x] >= TOPPLE) {
                                    grid[y][x] -= 4;
                                    if (x > 0) grid[y][x - 1] += 1;
                                    if (x < W - 1) grid[y][x + 1] += 1;
                                    if (y > 0) grid[y - 1][x] += 1;
                                    if (y < H - 1) grid[y + 1][x] += 1;
                                    unstable = true;
                                }
                            }
                        }
                    }
                }

                function resizeCanvasToHolder() {
                    if (!holder) return;
                    const rect = holder.getBoundingClientRect();
                    const w = Math.max(260, rect.width);
                    const h = rect.height || 260;
                    p.resizeCanvas(w, h);
                }

                p.setup = () => {
                    holder = document.getElementById("sandpile-holder");
                    const rect = holder.getBoundingClientRect();
                    const w = Math.max(260, rect.width);
                    const h = rect.height || 260;
                    canvas = p.createCanvas(w, h);
                    canvas.parent(holder);
                    p.frameRate(25);
                    initGrid();
                };

                p.windowResized = () => {
                    resizeCanvasToHolder();
                };

                p.draw = () => {
                    for (let i = 0; i < DROPS_PER_FRAME; i++) {
                        dropGrain();
                    }
                    relax();

                    p.background(3, 7, 18);
                    const cellSize = Math.min(p.width * 0.8 / W, p.height * 0.8 / H);
                    const offsetX = (p.width - cellSize * W) / 2;
                    const offsetY = (p.height - cellSize * H) / 2;

                    for (let y = 0; y < H; y++) {
                        for (let x = 0; x < W; x++) {
                            const h = grid[y][x] % 4;
                            let col;
                            if (h === 0) col = p.color(15, 23, 42);
                            else if (h === 1) col = p.color(55, 65, 81);
                            else if (h === 2) col = p.color(248, 250, 252);
                            else col = p.color(251, 191, 36);
                            p.noStroke();
                            p.fill(col);
                            p.rect(offsetX + x * cellSize, offsetY + y * cellSize, cellSize + 0.5,
                                cellSize + 0.5);
                        }
                    }

                    // HUD
                    p.noStroke();
                    p.fill(15, 23, 42, 220);
                    p.rect(0, 0, 260, 38);
                    p.fill(254, 243, 199);
                    p.textAlign(p.LEFT, p.TOP);
                    p.textSize(10);
                    p.text("Sandpile (self-organized criticality)", 8, 6);
                    p.fill(252, 211, 77);
                    p.textSize(9);
                    p.text("grains added slowly, topplings in bursts", 8, 20);
                };
            };

            new p5(sandSketch);
        })();
    </script>

    <!-- Percolation p5.js -->
    <script>
        (function () {
            const percSketch = (p) => {
                let canvas, holder;
                const W = 32;
                const H = 24;
                let openGrid = [];
                let cluster = [];
                const P = 0.59;
                let frameCounter = 0;

                function initGrid() {
                    openGrid = new Array(H);
                    cluster = new Array(H);
                    for (let y = 0; y < H; y++) {
                        openGrid[y] = new Array(W);
                        cluster[y] = new Array(W);
                        for (let x = 0; x < W; x++) {
                            openGrid[y][x] = Math.random() < P;
                            cluster[y][x] = false;
                        }
                    }

                    // flood fill from top row
                    const stack = [];
                    for (let x = 0; x < W; x++) {
                        if (openGrid[0][x]) {
                            cluster[0][x] = true;
                            stack.push({
                                x,
                                y: 0
                            });
                        }
                    }

                    const dirs = [{
                            dx: 1,
                            dy: 0
                        },
                        {
                            dx: -1,
                            dy: 0
                        },
                        {
                            dx: 0,
                            dy: 1
                        },
                        {
                            dx: 0,
                            dy: -1
                        }
                    ];

                    while (stack.length > 0) {
                        const {
                            x,
                            y
                        } = stack.pop();
                        for (let d of dirs) {
                            const nx = x + d.dx;
                            const ny = y + d.dy;
                            if (nx >= 0 && nx < W && ny >= 0 && ny < H) {
                                if (openGrid[ny][nx] && !cluster[ny][nx]) {
                                    cluster[ny][nx] = true;
                                    stack.push({
                                        x: nx,
                                        y: ny
                                    });
                                }
                            }
                        }
                    }
                }

                function resizeCanvasToHolder() {
                    if (!holder) return;
                    const rect = holder.getBoundingClientRect();
                    const w = Math.max(260, rect.width);
                    const h = rect.height || 260;
                    p.resizeCanvas(w, h);
                }

                p.setup = () => {
                    holder = document.getElementById("percolation-holder");
                    const rect = holder.getBoundingClientRect();
                    const w = Math.max(260, rect.width);
                    const h = rect.height || 260;
                    canvas = p.createCanvas(w, h);
                    canvas.parent(holder);
                    p.frameRate(10);
                    initGrid();
                };

                p.windowResized = () => {
                    resizeCanvasToHolder();
                };

                p.draw = () => {
                    frameCounter++;
                    if (frameCounter % 20 === 0) {
                        initGrid();
                    }

                    p.background(2, 6, 23);
                    const cellSize = Math.min(p.width * 0.8 / W, p.height * 0.8 / H);
                    const offsetX = (p.width - cellSize * W) / 2;
                    const offsetY = (p.height - cellSize * H) / 2;

                    let spanning = false;
                    for (let x = 0; x < W; x++) {
                        if (cluster[H - 1][x]) {
                            spanning = true;
                            break;
                        }
                    }

                    for (let y = 0; y < H; y++) {
                        for (let x = 0; x < W; x++) {
                            let col;
                            if (!openGrid[y][x]) {
                                col = p.color(15, 23, 42);
                            } else if (cluster[y][x]) {
                                col = spanning ? p.color(22, 163, 74) : p.color(34, 197, 94);
                            } else {
                                col = p.color(148, 163, 184);
                            }
                            p.noStroke();
                            p.fill(col);
                            p.rect(offsetX + x * cellSize, offsetY + y * cellSize, cellSize + 0.5,
                                cellSize + 0.5);
                        }
                    }

                    // HUD
                    p.noStroke();
                    p.fill(15, 23, 42, 220);
                    p.rect(0, 0, 260, 38);
                    p.fill(209, 250, 229);
                    p.textAlign(p.LEFT, p.TOP);
                    p.textSize(10);
                    p.text("Percolation on a grid", 8, 6);
                    p.fill(148, 163, 184);
                    p.textSize(9);
                    p.text(spanning ? "spanning cluster present" : "no spanning cluster", 8, 20);
                };
            };

            new p5(percSketch);
        })();
    </script>

    <!-- Forest fire p5.js -->
    <script>
        (function () {
            const forestSketch = (p) => {
                let canvas, holder;
                const W = 40;
                const H = 30;
                let grid = [];
                const EMPTY = 0;
                const TREE = 1;
                const FIRE = 2;

                const P_GROW = 0.02;
                const P_LIGHTNING = 0.0005;

                function initForest() {
                    grid = new Array(H);
                    for (let y = 0; y < H; y++) {
                        grid[y] = new Array(W);
                        for (let x = 0; x < W; x++) {
                            grid[y][x] = Math.random() < 0.3 ? TREE : EMPTY;
                        }
                    }
                }

                function stepForest() {
                    const newGrid = new Array(H);
                    for (let y = 0; y < H; y++) {
                        newGrid[y] = new Array(W);
                        for (let x = 0; x < W; x++) {
                            const state = grid[y][x];
                            if (state === FIRE) {
                                newGrid[y][x] = EMPTY;
                            } else if (state === TREE) {
                                // if any neighbor is burning, this catches fire
                                let burningNeighbor = false;
                                for (let dy = -1; dy <= 1; dy++) {
                                    for (let dx = -1; dx <= 1; dx++) {
                                        if (dx === 0 && dy === 0) continue;
                                        const nx = x + dx;
                                        const ny = y + dy;
                                        if (nx >= 0 && nx < W && ny >= 0 && ny < H) {
                                            if (grid[ny][nx] === FIRE) {
                                                burningNeighbor = true;
                                            }
                                        }
                                    }
                                }
                                if (burningNeighbor || Math.random() < P_LIGHTNING) {
                                    newGrid[y][x] = FIRE;
                                } else {
                                    newGrid[y][x] = TREE;
                                }
                            } else {
                                // empty
                                newGrid[y][x] = Math.random() < P_GROW ? TREE : EMPTY;
                            }
                        }
                    }
                    grid = newGrid;
                }

                function resizeCanvasToHolder() {
                    if (!holder) return;
                    const rect = holder.getBoundingClientRect();
                    const w = Math.max(260, rect.width);
                    const h = rect.height || 260;
                    p.resizeCanvas(w, h);
                }

                p.setup = () => {
                    holder = document.getElementById("forest-holder");
                    const rect = holder.getBoundingClientRect();
                    const w = Math.max(260, rect.width);
                    const h = rect.height || 260;
                    canvas = p.createCanvas(w, h);
                    canvas.parent(holder);
                    p.frameRate(20);
                    initForest();
                };

                p.windowResized = () => {
                    resizeCanvasToHolder();
                };

                p.draw = () => {
                    stepForest();

                    p.background(3, 6, 14);
                    const cellSize = Math.min(p.width * 0.8 / W, p.height * 0.8 / H);
                    const offsetX = (p.width - cellSize * W) / 2;
                    const offsetY = (p.height - cellSize * H) / 2;

                    for (let y = 0; y < H; y++) {
                        for (let x = 0; x < W; x++) {
                            const state = grid[y][x];
                            let col;
                            if (state === EMPTY) col = p.color(15, 23, 42);
                            else if (state === TREE) col = p.color(34, 197, 94);
                            else col = p.color(239, 68, 68);
                            p.noStroke();
                            p.fill(col);
                            p.rect(offsetX + x * cellSize, offsetY + y * cellSize, cellSize + 0.5,
                                cellSize + 0.5);
                        }
                    }

                    // HUD
                    p.noStroke();
                    p.fill(15, 23, 42, 220);
                    p.rect(0, 0, 260, 38);
                    p.fill(254, 226, 226);
                    p.textAlign(p.LEFT, p.TOP);
                    p.textSize(10);
                    p.text("Forest-fire model", 8, 6);
                    p.fill(248, 250, 252);
                    p.textSize(9);
                    p.text("trees grow slowly, fires burn fast", 8, 20);
                };
            };

            new p5(forestSketch);
        })();
    </script>

    <!-- Sidebar JS -->
    <script>
        (function () {
            const body = document.body;
            const toggleBtn = document.getElementById('info-toggle');
            const closeBtn = document.getElementById('info-close');
            const overlay = document.getElementById('info-overlay');

            function toggleSidebar(force) {
                const shouldOpen = typeof force === 'boolean' ? force : !body.classList.contains('sidebar-open');
                if (shouldOpen) {
                    body.classList.add('sidebar-open');
                } else {
                    body.classList.remove('sidebar-open');
                }
            }

            if (toggleBtn) {
                toggleBtn.addEventListener('click', () => toggleSidebar());
            }
            if (closeBtn) {
                closeBtn.addEventListener('click', () => toggleSidebar(false));
            }
            if (overlay) {
                overlay.addEventListener('click', () => toggleSidebar(false));
            }

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    toggleSidebar(false);
                }
            });
        })();
    </script>
</body>

</html>