<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Study Case ¬∑ Vibration on Bearings</title>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        body {
            background: #111;
            color: #eee;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            min-height: 100vh;
            min-height: 100dvh;
            display: flex;
            flex-direction: column;
        }

        .nav-btn {
            font-size: 12px;
            padding: 6px 14px;
            border-radius: 999px;
            border: 1px solid #3b3b3b;
            background: #222;
            color: #eee;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            transition: background .15s ease, border-color .15s ease, box-shadow .15s ease;
        }

        .nav-btn:hover {
            background: #2c2c2c;
            border-color: #7fffd4;
            box-shadow: 0 0 12px rgba(127, 255, 212, 0.25);
        }

        .page-body {
            padding: 18px 18px 48px;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }

        input[type="number"] {
            background: #111827;
            border-radius: 999px;
            border: 1px solid #374151;
            padding: 4px 10px;
            font-size: 12px;
            color: #e5e7eb;
            width: 90px;
        }

        input[type="number"]:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.5);
            border-color: #38bdf8;
        }

        .section-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #9ca3af;
        }

        .badge {
            border-radius: 999px;
            border: 1px solid #374151;
            padding: 2px 8px;
            font-size: 10px;
            color: #9ca3af;
        }
    </style>
</head>

<body>

    <!-- Top Navigation -->
    <header class="sticky top-0 z-40 backdrop-blur bg-zinc-900/75 border-b border-zinc-800">
        <div class="max-w-6xl mx-auto flex items-center justify-between px-4 py-3">
            <h1 class="font-semibold text-sm tracking-tight">
                Study Case: Vibration Analysis on Bearings ¬∑ Fourier & FFT
            </h1>

            <div class="flex items-center gap-2">
                <a href="../../fourier.html" class="nav-btn">‚Üê Back to Fourier's Lab</a>
                <a href="../../../index.html" class="nav-btn">Portfolio</a>
            </div>
        </div>
    </header>

    <div class="page-body">

        <p class="text-zinc-300 text-sm leading-6 mb-4 w-full px-2">
            Upload a vibration dataset (single-column CSV at 20 kHz), then run FFT and envelope analysis.
            Enter the shaft RPM so the tool can compute Rexnord ZA-2115 bearing defect frequencies
            (BPFO / BPFI / BSF / FTF) and compare them with the spectrum.

            Example CSV dataset can be found on: https://github.com/jaime385/Portfolio/tree/main/labs/vibration/bearings
        </p>

        <!-- Controls -->
        <div class="mb-4 px-2 flex flex-wrap gap-3 items-center">
            <button id="uploadBtn" class="nav-btn">üìÅ Upload CSV</button>
            <input type="file" id="fileInput" accept=".csv" class="hidden">

            <button id="fftBtn" class="nav-btn">‚ö° Run FFT + Envelope</button>

            <span class="text-xs text-zinc-400 ml-2 flex items-center gap-2">
                <span class="section-title">Machine speed</span>
                <label class="flex items-center gap-1">
                    <span class="text-[11px] text-zinc-400">RPM</span>
                    <input type="number" id="rpmInput" value="1800" step="10" min="1">
                </label>
                <span id="infoLabel" class="text-[11px] text-zinc-400"></span>
            </span>
        </div>

        <!-- Canvas container -->
        <div id="vibration-canvas-container"
            class="w-full h-[450px] border border-zinc-700 rounded-xl bg-black/60 mb-4">
        </div>

        <!-- Bearing frequencies + diagnostics -->
        <div class="px-2 mt-2 grid grid-cols-1 md:grid-cols-2 gap-4 text-xs">
            <div>
                <div class="flex items-center justify-between mb-1">
                    <span class="section-title">ZA-2115 characteristic frequencies</span>
                    <span class="badge">f = factor √ó RPM / 60</span>
                </div>
                <table class="text-[11px] text-zinc-300">
                    <tbody id="bearingFreqTable"></tbody>
                </table>
            </div>

            <div>
                <div class="flex items-center justify-between mb-1">
                    <span class="section-title">Basic diagnostic (envelope-based)</span>
                    <span class="badge" id="diagConfidence"></span>
                </div>
                <div id="diagnosticText" class="text-[11px] text-zinc-300 leading-relaxed"></div>
            </div>
        </div>

    </div>

    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.2/lib/p5.min.js"></script>

    <script>
        // ------------------ DATA & CONSTANTS ------------------
        let samples = [];
        const sampleRate = 20000; // Hz (IMS bearing dataset)

        let durationSec = 0;

        // time-domain scaling
        let yMin = -1;
        let yMax = 1;

        // FFT data (raw signal)
        let fftMagnitudes = [];
        let fftFreqs = [];
        let fftPeaks = [];
        let fftComputed = false;

        // Envelope FFT data (for diagnostics)
        let envMagnitudes = [];
        let envFreqs = [];
        let envPeaks = [];
        let envComputed = false;

        const margin = {
            left: 60,
            right: 20,
            top: 20,
            bottom: 40
        };

        const infoLabel = document.getElementById("infoLabel");
        const rpmInput = document.getElementById("rpmInput");
        const bearingFreqTable = document.getElementById("bearingFreqTable");
        const diagnosticText = document.getElementById("diagnosticText");
        const diagConfidence = document.getElementById("diagConfidence");

        // Rexnord ZA-2115 double-row spherical roller factors (cycles per shaft rev)
        const bearingFactors = {
            shaft: 1.0, // 1√ó running speed
            BPFO: 0.1217, // outer race
            BPFI: 0.1617, // inner race
            BSF: 0.0559, // roller spin
            FTF: 0.0072 // cage
        };

        // ------------------ FILE I/O ------------------

        document.getElementById("uploadBtn").addEventListener("click", () => {
            document.getElementById("fileInput").click();
        });

        document.getElementById("fileInput").addEventListener("change", (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const text = e.target.result;
                samples = text.trim().split(/\r?\n/).map(Number);

                durationSec = samples.length / sampleRate;

                // auto-scale y axis using max absolute amplitude
                const minVal = Math.min(...samples);
                const maxVal = Math.max(...samples);
                const maxAbs = Math.max(Math.abs(minVal), Math.abs(maxVal));
                yMin = -maxAbs;
                yMax = maxAbs;

                fftComputed = false;
                envComputed = false;
                fftPeaks = [];
                envPeaks = [];

                infoLabel.textContent = `Loaded ${samples.length} samples (~${durationSec.toFixed(3)} s).`;
                console.log("Loaded samples:", samples.length, "duration (s):", durationSec.toFixed(3));
            };
            reader.readAsText(file);
        });

        document.getElementById("fftBtn").addEventListener("click", () => {
            if (samples.length === 0) {
                infoLabel.textContent = "Load a CSV first.";
                return;
            }
            computeAllSpectra();
        });

        // ------------------ p5 SETUP ------------------

        function setup() {
            const container = document.getElementById("vibration-canvas-container");
            const c = createCanvas(container.clientWidth, container.clientHeight);
            c.parent("vibration-canvas-container");
            textFont("system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif");
        }

        // ------------------ DRAW HELPERS ------------------

        function drawTimeAxes(plotLeft, plotRight, plotTop, plotBottom) {
            stroke(100);
            strokeWeight(1);
            fill(200);
            textSize(10);

            // X axis (time)
            line(plotLeft, plotBottom, plotRight, plotBottom);

            // Y axis (amplitude)
            line(plotLeft, plotTop, plotLeft, plotBottom);

            // X ticks (0 .. duration)
            if (durationSec > 0) {
                const nTicks = 4;
                for (let i = 0; i <= nTicks; i++) {
                    const t = (durationSec * i) / nTicks;
                    const x = map(i, 0, nTicks, plotLeft, plotRight);
                    stroke(80);
                    line(x, plotBottom, x, plotBottom + 4);
                    noStroke();
                    textAlign(CENTER, TOP);
                    text(t.toFixed(2) + " s", x, plotBottom + 6);
                }
            }

            // y labels at +peak, 0, -peak
            const yLabels = [yMax, 0, yMin];
            const yLabelNames = [
                "+" + yMax.toFixed(3),
                "0",
                "-" + Math.abs(yMin).toFixed(3)
            ];

            for (let i = 0; i < yLabels.length; i++) {
                const val = yLabels[i];
                const y = map(val, yMin, yMax, plotBottom, plotTop);
                stroke(60);
                line(plotLeft - 4, y, plotLeft, y);
                noStroke();
                textAlign(RIGHT, CENTER);
                text(yLabelNames[i], plotLeft - 8, y);
            }

            // Axis labels
            noStroke();
            textAlign(CENTER, BOTTOM);
            text("Time (seconds)", (plotLeft + plotRight) / 2, plotBottom + 22);

            push();
            translate(plotLeft - 40, (plotTop + plotBottom) / 2);
            rotate(-HALF_PI);
            textAlign(CENTER, CENTER);
            text("Acceleration (normalized)", 0, 0);
            pop();
        }

        function drawWaveform(plotLeft, plotRight, plotTop, plotBottom) {
            if (samples.length === 0) return;

            const plotWidth = plotRight - plotLeft;

            stroke(0, 255, 180);
            strokeWeight(1);
            noFill();

            beginShape();
            for (let i = 0; i < samples.length; i++) {
                const x = plotLeft + (i / (samples.length - 1)) * plotWidth;
                const y = map(samples[i], yMin, yMax, plotBottom, plotTop);
                vertex(x, y);
            }
            endShape();

            // Zero line
            stroke(80, 200);
            const yZero = map(0, yMin, yMax, plotBottom, plotTop);
            line(plotLeft, yZero, plotRight, yZero);
        }

        function drawFFTAxes(plotLeft, plotRight, plotTop, plotBottom) {
            if (!fftComputed) return;

            stroke(100);
            strokeWeight(1);
            fill(200);
            textSize(10);

            // X axis
            line(plotLeft, plotBottom, plotRight, plotBottom);
            // Y axis
            line(plotLeft, plotTop, plotLeft, plotBottom);

            const maxFreq = fftFreqs.length ? fftFreqs[fftFreqs.length - 1] : sampleRate / 2;
            const tickFreqs = [0, 2000, 5000, 10000];
            tickFreqs.forEach(f => {
                if (f <= maxFreq) {
                    const x = map(f, 0, maxFreq, plotLeft, plotRight);
                    stroke(80);
                    line(x, plotBottom, x, plotBottom + 4);
                    noStroke();
                    textAlign(CENTER, TOP);
                    text((f / 1000).toFixed(1) + " kHz", x, plotBottom + 6);
                }
            });

            // Y label just "0 .. 1 (norm)"
            noStroke();
            textAlign(RIGHT, TOP);
            text("1.0", plotLeft - 8, plotTop);
            textAlign(RIGHT, BOTTOM);
            text("0.0", plotLeft - 8, plotBottom);

            // Axis labels
            textAlign(CENTER, BOTTOM);
            text("Frequency (Hz)", (plotLeft + plotRight) / 2, plotBottom + 22);

            push();
            translate(plotLeft - 40, (plotTop + plotBottom) / 2);
            rotate(-HALF_PI);
            textAlign(CENTER, CENTER);
            text("Magnitude (normalized)", 0, 0);
            pop();
        }

        function drawFFT(plotLeft, plotRight, plotTop, plotBottom) {
            if (!fftComputed || fftMagnitudes.length === 0) return;

            const plotWidth = plotRight - plotLeft;
            const maxFreq = fftFreqs[fftFreqs.length - 1];

            stroke(0, 180, 255);
            strokeWeight(1);
            noFill();

            beginShape();
            for (let i = 0; i < fftMagnitudes.length; i++) {
                const x = plotLeft + (fftFreqs[i] / maxFreq) * plotWidth;
                const y = map(fftMagnitudes[i], 0, 1, plotBottom, plotTop);
                vertex(x, y);
            }
            endShape();

            // Peak legend (FFT)
            if (fftPeaks.length > 0) {
                const legendX = plotRight - 180;
                const legendY = plotTop + 6;

                noStroke();
                fill(0, 0, 0, 150);
                rect(legendX - 6, legendY - 4, 180, 16 + 12 * fftPeaks.length);

                fill(230, 220, 190);
                textAlign(LEFT, TOP);
                textSize(10);
                text("Main peaks (FFT):", legendX, legendY);

                for (let i = 0; i < fftPeaks.length; i++) {
                    const p = fftPeaks[i];
                    const lineY = legendY + 12 * (i + 1);
                    const freqTxt = p.freq >= 1000 ?
                        `${(p.freq / 1000).toFixed(2)} kHz` :
                        `${p.freq.toFixed(1)} Hz`;
                    text(`${i + 1}) ${freqTxt}  (mag ‚âà ${p.mag.toFixed(3)})`, legendX, lineY);
                }
            }
        }

        // Envelope spectrum (bottom area, up to 500 Hz)
        function drawEnvAxes(plotLeft, plotRight, plotTop, plotBottom) {
            if (!envComputed) return;

            stroke(100);
            strokeWeight(1);
            fill(200);
            textSize(10);

            line(plotLeft, plotBottom, plotRight, plotBottom);
            line(plotLeft, plotTop, plotLeft, plotBottom);

            const maxFreq = 500; // show 0‚Äì500 Hz
            const tickFreqs = [0, 50, 100, 200, 300, 400, 500];
            tickFreqs.forEach(f => {
                const x = map(f, 0, maxFreq, plotLeft, plotRight);
                stroke(80);
                line(x, plotBottom, x, plotBottom + 4);
                noStroke();
                textAlign(CENTER, TOP);
                text(f + " Hz", x, plotBottom + 5);
            });

            noStroke();
            textAlign(RIGHT, TOP);
            text("1.0", plotLeft - 8, plotTop);
            textAlign(RIGHT, BOTTOM);
            text("0.0", plotLeft - 8, plotBottom);

            textAlign(CENTER, BOTTOM);
            text("Envelope frequency (Hz)", (plotLeft + plotRight) / 2, plotBottom + 22);

            push();
            translate(plotLeft - 54, (plotTop + plotBottom) / 2);
            rotate(-HALF_PI);
            textAlign(CENTER, CENTER);
            text("Envelope magnitude (normalized)", 0, 0);
            pop();
        }

        function drawEnvSpectrum(plotLeft, plotRight, plotTop, plotBottom) {
            if (!envComputed || envMagnitudes.length === 0) return;

            const maxFreq = 500; // we only care about low-frequency envelope
            const maxIdx = envFreqs.findIndex(f => f > maxFreq);
            const lastIdx = maxIdx === -1 ? envFreqs.length - 1 : maxIdx;

            stroke(245, 158, 11); // amber-ish
            strokeWeight(1);
            noFill();

            beginShape();
            for (let i = 0; i <= lastIdx; i++) {
                const x = map(envFreqs[i], 0, maxFreq, plotLeft, plotRight);
                const y = map(envMagnitudes[i], 0, 1, plotBottom, plotTop);
                vertex(x, y);
            }
            endShape();

            // peaks legend (envelope)
            if (envPeaks.length > 0) {
                const legendX = plotLeft + 10;
                const legendY = plotTop + 6;

                noStroke();
                fill(0, 0, 0, 150);
                rect(legendX - 6, legendY - 4, 200, 16 + 12 * envPeaks.length);

                fill(252, 211, 77);
                textAlign(LEFT, TOP);
                textSize(10);
                text("Main peaks (envelope):", legendX, legendY);

                for (let i = 0; i < envPeaks.length; i++) {
                    const p = envPeaks[i];
                    const lineY = legendY + 12 * (i + 1);
                    text(
                        `${i + 1}) ${p.freq.toFixed(1)} Hz  (mag ‚âà ${p.mag.toFixed(3)})`,
                        legendX,
                        lineY
                    );
                }
            }
        }

        function draw() {
            background(0);

            const plotLeft = margin.left;
            const plotRight = width - margin.right;
            const fullTop = margin.top;
            const fullBottom = height - margin.bottom;

            // divide: top = time, middle = FFT, bottom = envelope
            const timeHeight = 0.35;
            const fftHeight = 0.30;

            const timeTop = fullTop;
            const timeBottom = timeTop + (fullBottom - fullTop) * timeHeight;

            const fftTop = timeBottom + 8;
            const fftBottom = fftTop + (fullBottom - fullTop) * fftHeight;

            const envTop = fftBottom + 8;
            const envBottom = fullBottom;

            drawTimeAxes(plotLeft, plotRight, timeTop, timeBottom);
            drawWaveform(plotLeft, plotRight, timeTop, timeBottom);

            drawFFTAxes(plotLeft, plotRight, fftTop, fftBottom);
            drawFFT(plotLeft, plotRight, fftTop, fftBottom);

            drawEnvAxes(plotLeft, plotRight, envTop, envBottom);
            drawEnvSpectrum(plotLeft, plotRight, envTop, envBottom);
        }

        // ------------------ FFT / ENVELOPE IMPLEMENTATION ------------------

        function largestPow2LE(n) {
            let N = 1;
            while ((N << 1) <= n) N <<= 1;
            return N;
        }

        // Reusable FFT for real-valued signal
        function fftReal(signal, fs, maxPeaks) {
            const N = largestPow2LE(signal.length);
            if (N < 1024) {
                throw new Error("Not enough samples for FFT");
            }

            const re = new Array(N);
            const im = new Array(N).fill(0);

            // Hann window
            for (let i = 0; i < N; i++) {
                const w = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (N - 1)));
                re[i] = signal[i] * w;
            }

            // Bit-reversal
            let j = 0;
            for (let i = 0; i < N; i++) {
                if (i < j) {
                    [re[i], re[j]] = [re[j], re[i]];
                    [im[i], im[j]] = [im[j], im[i]];
                }
                let m = N >> 1;
                while (m >= 1 && j >= m) {
                    j -= m;
                    m >>= 1;
                }
                j += m;
            }

            // Cooley‚ÄìTukey
            for (let len = 2; len <= N; len <<= 1) {
                const ang = -2 * Math.PI / len;
                const wlenCos = Math.cos(ang);
                const wlenSin = Math.sin(ang);

                for (let i = 0; i < N; i += len) {
                    let wCos = 1;
                    let wSin = 0;
                    for (let k = 0; k < len / 2; k++) {
                        const uRe = re[i + k];
                        const uIm = im[i + k];
                        const vRe = re[i + k + len / 2] * wCos - im[i + k + len / 2] * wSin;
                        const vIm = re[i + k + len / 2] * wSin + im[i + k + len / 2] * wCos;

                        re[i + k] = uRe + vRe;
                        im[i + k] = uIm + vIm;
                        re[i + k + len / 2] = uRe - vRe;
                        im[i + k + len / 2] = uIm - vIm;

                        const nextCos = wCos * wlenCos - wSin * wlenSin;
                        const nextSin = wCos * wlenSin + wSin * wlenCos;
                        wCos = nextCos;
                        wSin = nextSin;
                    }
                }
            }

            const half = N / 2;
            let mags = [];
            let freqs = [];
            let maxMag = 0;

            for (let k = 0; k < half; k++) {
                const mag = Math.sqrt(re[k] * re[k] + im[k] * im[k]);
                mags.push(mag);
                if (mag > maxMag) maxMag = mag;
                freqs.push(k * fs / N);
            }

            // normalize
            if (maxMag > 0) {
                mags = mags.map(m => m / maxMag);
            }

            // peak detection (skip DC)
            const peaks = [];
            const magsWithIndex = [];
            for (let k = 1; k < half - 1; k++) {
                magsWithIndex.push({
                    index: k,
                    mag: mags[k]
                });
            }
            magsWithIndex.sort((a, b) => b.mag - a.mag);

            const numPeaks = maxPeaks || 5;
            for (let p = 0; p < Math.min(numPeaks, magsWithIndex.length); p++) {
                const idx = magsWithIndex[p].index;
                peaks.push({
                    index: idx,
                    freq: freqs[idx],
                    mag: mags[idx]
                });
            }

            return {
                N,
                freqs,
                mags,
                peaks,
                df: fs / N
            };
        }

        function movingAverage(arr, windowSamples) {
            const out = new Array(arr.length).fill(0);
            if (windowSamples <= 1) return arr.slice();
            let acc = 0;
            let w = windowSamples;

            for (let i = 0; i < arr.length; i++) {
                acc += arr[i];
                if (i >= w) acc -= arr[i - w];
                const denom = i + 1 < w ? i + 1 : w;
                out[i] = acc / denom;
            }
            return out;
        }

        function computeAllSpectra() {
            try {
                // ---- raw FFT ----
                const fft = fftReal(samples, sampleRate, 5);
                fftMagnitudes = fft.mags;
                fftFreqs = fft.freqs;
                fftPeaks = fft.peaks;
                fftComputed = true;

                // ---- envelope ----
                // crude envelope: rectified + moving-average low-pass, then remove DC
                const rect = samples.map(v => Math.abs(v));
                const winSamples = Math.round(sampleRate * 0.002); // ~2 ms
                let env = movingAverage(rect, winSamples);

                // remove DC
                const mean = env.reduce((a, b) => a + b, 0) / env.length;
                env = env.map(v => v - mean);

                const envFft = fftReal(env, sampleRate, 5);
                envMagnitudes = envFft.mags;
                envFreqs = envFft.freqs;
                envPeaks = envFft.peaks;
                envComputed = true;

                infoLabel.textContent =
                    `FFT N = ${fft.N} (Œîf ‚âà ${envFft.df.toFixed(2)} Hz).  Envelope also computed.`;

                updateBearingFrequencyTable();
                updateDiagnostics();

                console.log("FFT df:", fft.df, "Envelope df:", envFft.df);
            } catch (err) {
                console.error(err);
                infoLabel.textContent = err.message;
            }
        }

        // ------------------ BEARING FREQS & DIAGNOSTICS ------------------

        function getRPM() {
            const rpm = parseFloat(rpmInput.value);
            return isFinite(rpm) && rpm > 0 ? rpm : 0;
        }

        function updateBearingFrequencyTable() {
            const rpm = getRPM();
            bearingFreqTable.innerHTML = "";

            if (!rpm) {
                bearingFreqTable.innerHTML =
                    `<tr><td class="text-zinc-500">Enter a valid RPM to compute frequencies.</td></tr>`;
                return;
            }

            const shaftHz = rpm / 60;

            const rows = [{
                    label: "1√ó running speed",
                    key: "shaft"
                },
                {
                    label: "BPFO (outer race)",
                    key: "BPFO"
                },
                {
                    label: "BPFI (inner race)",
                    key: "BPFI"
                },
                {
                    label: "BSF (roller spin)",
                    key: "BSF"
                },
                {
                    label: "FTF (cage)",
                    key: "FTF"
                }
            ];

            rows.forEach(row => {
                const factor = bearingFactors[row.key];
                const fHz = shaftHz * factor;
                const fTxt = fHz >= 1000 ?
                    `${(fHz / 1000).toFixed(2)} kHz` :
                    `${fHz.toFixed(1)} Hz`;
                const tr = document.createElement("tr");
                tr.innerHTML = `
                    <td class="pr-3 text-zinc-400">${row.label}</td>
                    <td class="pr-2 text-zinc-500">${factor.toFixed(4)} √ó RPM</td>
                    <td class="font-mono text-zinc-200">${fTxt}</td>`;
                bearingFreqTable.appendChild(tr);
            });
        }

        function nearestPeak(peaks, targetHz) {
            if (!peaks || peaks.length === 0) return null;
            let best = null;
            let bestErr = Infinity;
            for (const p of peaks) {
                const err = Math.abs(p.freq - targetHz);
                if (err < bestErr) {
                    bestErr = err;
                    best = {
                        ...p,
                        errHz: err
                    };
                }
            }
            return best;
        }

        function updateDiagnostics() {
            const rpm = getRPM();
            if (!rpm || !envComputed) {
                diagnosticText.textContent =
                    "Run FFT + envelope and enter the shaft RPM to see a basic diagnosis.";
                diagConfidence.textContent = "";
                return;
            }

            const shaftHz = rpm / 60;
            const freqs = {
                shaft: shaftHz * bearingFactors.shaft,
                BPFO: shaftHz * bearingFactors.BPFO,
                BPFI: shaftHz * bearingFactors.BPFI,
                BSF: shaftHz * bearingFactors.BSF,
                FTF: shaftHz * bearingFactors.FTF
            };

            // Compare envelope peaks with bearing defect freqs
            const tol = f => Math.max(5, f * 0.05); // 5 Hz or ¬±5%
            const matches = [];

            for (const key of ["BPFO", "BPFI", "BSF", "FTF"]) {
                const fTarget = freqs[key];
                const p = nearestPeak(envPeaks, fTarget);
                if (!p) continue;
                if (p.errHz <= tol(fTarget)) {
                    matches.push({
                        key,
                        fTarget,
                        peak: p
                    });
                }
            }

            let text = "";

            if (matches.length === 0) {
                text +=
                    "No strong envelope peaks are landing near the classical bearing defect " +
                    "frequencies for the ZA-2115 (BPFO/BPFI/BSF/FTF). The signal may be dominated " +
                    "by broadband vibration or other sources (unbalance, random noise, etc.).";
                diagConfidence.textContent = "Low evidence of localized race/roller defects";
            } else {
                diagConfidence.textContent = "Potential bearing defect detected";

                text += "Envelope analysis shows peaks close to the theoretical bearing defect " +
                    "frequencies. This is a rough indication only ‚Äì use it as a hint, not a final verdict.\n\n";

                matches.forEach(m => {
                    const labelMap = {
                        BPFO: "BPFO (outer race defect)",
                        BPFI: "BPFI (inner race defect)",
                        BSF: "BSF (roller/element defect)",
                        FTF: "FTF (cage / train defect)"
                    };

                    text += `${labelMap[m.key]}:\n`;
                    text += `  ‚Ä¢ Expected: ${m.fTarget.toFixed(1)} Hz\n`;
                    text +=
                        `  ‚Ä¢ Envelope peak: ${m.peak.freq.toFixed(1)} Hz (mag ‚âà ${m.peak.mag.toFixed(3)}, ` +
                        `Œîf ‚âà ${m.peak.errHz.toFixed(2)} Hz)\n\n`;
                });

                text +=
                    "If BPFO dominates ‚Üí outer race damage is more likely.\n" +
                    "If BPFI dominates ‚Üí inner race damage is more likely.\n" +
                    "If BSF dominates ‚Üí rolling element issues (spalls, flats) are suspected.\n" +
                    "If FTF shows up strongly ‚Üí cage looseness or defects might be present.\n";
            }

            diagnosticText.textContent = text;
        }

        // keep table/diagnostics in sync if user changes RPM after analysis
        rpmInput.addEventListener("change", () => {
            updateBearingFrequencyTable();
            updateDiagnostics();
        });
    </script>

</body>

</html>